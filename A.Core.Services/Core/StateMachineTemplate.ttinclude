<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE"#>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Xml" #>

<#+
        [XmlRoot(ElementName = "ArrayOfExtensiblePropertyInstance", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class ArrayOfExtensiblePropertyInstance
        {
            [XmlAttribute(AttributeName = "xsi", Namespace = "http://www.w3.org/2000/xmlns/")]
            public string Xsi { get; set; }
            [XmlAttribute(AttributeName = "xsd", Namespace = "http://www.w3.org/2000/xmlns/")]
            public string Xsd { get; set; }
        }

        [XmlRoot(ElementName = "stateMoniker", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class StateMoniker
        {
            [XmlAttribute(AttributeName = "name")]
            public string Name { get; set; }
        }

        [XmlRoot(ElementName = "flow", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class Flow
        {
            [XmlElement(ElementName = "ArrayOfExtensiblePropertyInstance", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public ArrayOfExtensiblePropertyInstance ArrayOfExtensiblePropertyInstance { get; set; }
            [XmlElement(ElementName = "stateMoniker", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public StateMoniker StateMoniker { get; set; }
			[XmlAttribute(AttributeName = "guard")]
            public string Guard { get; set; }
            [XmlAttribute(AttributeName = "eventAndGuardLabel")]
            public string EventAndGuardLabel { get; set; }
            [XmlAttribute(AttributeName = "effectLabel")]
            public string EffectLabel { get; set; }
            [XmlAttribute(AttributeName = "eventGuardEffectLabel")]
            public string EventGuardEffectLabel { get; set; }
            [XmlElement(ElementName = "endPointMoniker", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public EndPointMoniker EndPointMoniker { get; set; }
        }

        [XmlRoot(ElementName = "flowTo", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class FlowTo
        {
            [XmlElement(ElementName = "flow", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public List<Flow> Flow { get; set; }
        }

        [XmlRoot(ElementName = "startPoint", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class StartPoint
        {
            [XmlElement(ElementName = "ArrayOfExtensiblePropertyInstance", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public ArrayOfExtensiblePropertyInstance ArrayOfExtensiblePropertyInstance { get; set; }
            [XmlElement(ElementName = "flowTo", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public FlowTo FlowTo { get; set; }
            [XmlAttribute(AttributeName = "name")]
            public string Name { get; set; }
        }

        [XmlRoot(ElementName = "state", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class State
        {
            [XmlElement(ElementName = "ArrayOfExtensiblePropertyInstance", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public ArrayOfExtensiblePropertyInstance ArrayOfExtensiblePropertyInstance { get; set; }
            [XmlElement(ElementName = "flowTo", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public FlowTo FlowTo { get; set; }
            [XmlAttribute(AttributeName = "name")]
            public string Name { get; set; }
            [XmlAttribute(AttributeName = "entryActionLabel")]
            public string EntryActionLabel { get; set; }
            [XmlAttribute(AttributeName = "exitActionLabel")]
            public string ExitActionLabel { get; set; }
        }

        [XmlRoot(ElementName = "endPointMoniker", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class EndPointMoniker
        {
            [XmlAttribute(AttributeName = "name")]
            public string Name { get; set; }
        }

        [XmlRoot(ElementName = "endPoint", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class EndPoint
        {
            [XmlElement(ElementName = "ArrayOfExtensiblePropertyInstance", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public ArrayOfExtensiblePropertyInstance ArrayOfExtensiblePropertyInstance { get; set; }
            [XmlAttribute(AttributeName = "name")]
            public string Name { get; set; }
        }

        [XmlRoot(ElementName = "flowElements", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class FlowElements
        {
            [XmlElement(ElementName = "startPoint", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public StartPoint StartPoint { get; set; }
            [XmlElement(ElementName = "state", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public List<State> State { get; set; }
            [XmlElement(ElementName = "endPoint", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public EndPoint EndPoint { get; set; }
        }

        [XmlRoot(ElementName = "stateGraph", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
        public class StateGraph
        {
            [XmlElement(ElementName = "flowElements", Namespace = "http://www.tangiblearchitect.com/dsltools/State")]
            public FlowElements FlowElements { get; set; }
            [XmlAttribute(AttributeName = "dm0", Namespace = "http://www.w3.org/2000/xmlns/")]
            public string Dm0 { get; set; }
            [XmlAttribute(AttributeName = "dslVersion")]
            public string DslVersion { get; set; }
            [XmlAttribute(AttributeName = "name")]
            public string Name { get; set; }
            [XmlAttribute(AttributeName = "xmlns")]
            public string Xmlns { get; set; }
			[XmlAttribute(AttributeName = "description")]
            public string Description { get; set; }
        }


public class StateMachineTemplate : TextTransformation
{
	public string StateMachineAttribute = "A.Core.Attributes.StateMachineAttribute";
	public string DefaultMethodBehaviourAttribute = "A.Core.Attributes.DefaultMethodBehaviourAttribute";
	ServiceTemplateConfig Config {get; set;}
	AutomationHelper VisualStudioHelper {get; set;}
	IList<EnvDTE.CodeInterface> InterfaceList {get; set;}
	EnvDTE.CodeInterface Interface {get; set;}
	StateGraph CurrentStateGraph {get; set;}
	public StateMachineTemplate(IList<EnvDTE.CodeInterface> interfaceList, ServiceTemplateConfig config, AutomationHelper helper)
	{
		VisualStudioHelper = helper;
		Config = config;
		InterfaceList = interfaceList;
		
	}
	/// <summary>
	/// Gets a list of all triggers in the diagram.
	/// </summary>
		List<string> GetGuardNames(StateGraph sg)
        {
            var ret = new List<string>();

            // iterate all states
            foreach (State s in sg.FlowElements.State)
            {
                if(s.FlowTo != null)
                {
                    // get all flows where s is the start point
                    foreach (Flow f in s.FlowTo.Flow)
                    {
						if(!string.IsNullOrWhiteSpace(f.Guard))
                        {
							string name = f.Guard.Replace("/","");
							if (!ret.Contains(name) && !string.IsNullOrEmpty(name))
                            {
								ret.Add(name);
                            }
                        }
                    }
                }
            }

            return ret;
        }

		List<string> GetGuardNamesForState(State s)
        {
            var ret = new List<string>();

			if(s.FlowTo != null)
			{
				// get all flows where s is the start point
				foreach (Flow f in s.FlowTo.Flow)
				{
					if(!string.IsNullOrWhiteSpace(f.Guard))
					{
						string name = f.Guard.Replace("/","");
						if (!ret.Contains(name) && !string.IsNullOrEmpty(name))
						{
							ret.Add(name);
						}
					}
				}
			}

            return ret;
        }

	public bool IsValidForCreatingStateMachine(EnvDTE.CodeInterface @interface)
    {
		bool isExisting = false;
		var allAttributes = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(@interface.Attributes, vsCMElement.vsCMElementAttribute, false);
		foreach(EnvDTE.CodeAttribute attribute in allAttributes)
        {
			if(attribute.FullName == StateMachineAttribute)
            {
				isExisting = true;
				break;
            }
        }
		return isExisting;
    }

	public string GetStateMachineName()
    {
		var allAttributes = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(Interface.Attributes, vsCMElement.vsCMElementAttribute, false);
		foreach(EnvDTE.CodeAttribute attribute in allAttributes)
        {
			if(attribute.FullName == StateMachineAttribute)
            {
				return attribute.Value.Split(',')[0].Trim().Trim('"');
            }
        }
		
		throw new Exception("State machine name not found on:" + Interface.FullName);
    }

	public string GetStateMachineEnumName()
    {
		var allAttributes = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(Interface.Attributes, vsCMElement.vsCMElementAttribute, false);
		foreach(EnvDTE.CodeAttribute attribute in allAttributes)
        {
			if(attribute.FullName == StateMachineAttribute)
            {
				return attribute.Value.Split(',')[1].Trim().Trim('"');
            }
        }
		
		throw new Exception("State machine name not found on:" + Interface.FullName);
    }

	public string GetStateMachinePropertyNameOnModel()
    {
		var allAttributes = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(Interface.Attributes, vsCMElement.vsCMElementAttribute, false);
		foreach(EnvDTE.CodeAttribute attribute in allAttributes)
        {
			if(attribute.FullName == StateMachineAttribute)
            {
				return attribute.Value.Split(',')[2].Trim().Trim('"');
            }
        }
		
		throw new Exception("State machine name not found on:" + Interface.FullName);
    }


	public string GetNextStateName(State state, string flowName)
    {
        string nextStateName = "";
        if(state.FlowTo != null)
        {
            foreach(var currentFlow in state.FlowTo.Flow)
            {
                if(currentFlow != null && currentFlow.EventAndGuardLabel != null
					&& currentFlow.StateMoniker != null)
                {
                    if(currentFlow.EventAndGuardLabel.TrimEnd('/') == flowName)
                    {
						if(!string.IsNullOrWhiteSpace(CurrentStateGraph.Name))
                        {
							nextStateName = currentFlow.StateMoniker.Name.Remove(0, CurrentStateGraph.Name.Length + 1).TrimStart('/');
                        }
						else
                        {
							nextStateName = currentFlow.StateMoniker.Name.TrimStart('/');
						}
                        
                        break;
                    }
                }
            }
        }
        return nextStateName;
    }

	public string GetNextStateName(StartPoint state, string flowName)
    {
        string nextStateName = "";
        if(state.FlowTo != null)
        {
            foreach(var currentFlow in state.FlowTo.Flow)
            {
                if(currentFlow != null && currentFlow.EventAndGuardLabel != null
					&& currentFlow.StateMoniker != null)
                {
                    if(currentFlow.EventAndGuardLabel.TrimEnd('/') == flowName)
                    {
						if(!string.IsNullOrWhiteSpace(CurrentStateGraph.Name))
                        {
							nextStateName = currentFlow.StateMoniker.Name.Remove(0, CurrentStateGraph.Name.Length + 1).TrimStart('/');
                        }
						else
                        {
							nextStateName = currentFlow.StateMoniker.Name.TrimStart('/');
						}
                        
                        break;
                    }
                }
            }
        }
        return nextStateName;
    }


    public override string TransformText()
    {
		//we will first create for each state new class and state machine
		foreach(var @interface in InterfaceList)
        {
			if(IsValidForCreatingStateMachine(@interface))
            {
				Interface = @interface; //we will now proceed rendering based on this interface
				XmlSerializer ser = new XmlSerializer(typeof(StateGraph));
				string fileName = "";
				foreach(var projectName in Config.ModelProjectList)
				{
					var project = VisualStudioHelper.GetProject(projectName);
        
					WriteLine("//file:"+project.FullName + "_" + System.IO.Path.GetDirectoryName(project.FullName));
					var files = Directory.EnumerateFiles(System.IO.Path.GetDirectoryName(project.FullName), GetStateMachineName() +".tastate", SearchOption.AllDirectories);
					if(files.Count() != 1)
                    {
						continue;
                    }
					foreach(var file in files)
                    {
						fileName = file;
						break;
                    }
				}
				WriteLine("//Creating state machine from: "+fileName);
				using (XmlReader reader = XmlReader.Create(fileName))
				{
					CurrentStateGraph = (StateGraph)ser.Deserialize(reader);
				}
				var stateMachineName = GetStateMachineName();
#>
				//StateMachine: <#= Interface.Name #>, name: <#= GetStateMachineName() #>, graphCount <#= CurrentStateGraph.FlowElements.State.Count #>, enum <#= CurrentStateGraph.Description #>
<#+ 
				var startPoint = this.CurrentStateGraph.FlowElements.StartPoint;
				if(startPoint != null)
                {
#>
				public partial class <#= stateMachineName#><#= startPoint.Name #>State : <#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.StateBase 
				{
<#+
					if(!string.IsNullOrWhiteSpace(GetStateMachineEnumName()))
                    {
#>
					protected <#=GetStateMachineEnumName()#> mStateId = <#=GetStateMachineEnumName()#>.<#= startPoint.Name#>;
<#+ 
					}
#>
					public <#= stateMachineName#><#= startPoint.Name #>State(<#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.StateMachineBase machine) : base(machine) 
					{
						StateId = (int)mStateId;
					}
				}
<#+ 
                }
#>

<#+ 
				foreach(var state in this.CurrentStateGraph.FlowElements.State)
                {
#>
				public partial class <#= stateMachineName#><#= state.Name #>State : <#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.StateBase 
				{
<#+
					if(!string.IsNullOrWhiteSpace(GetStateMachineEnumName()))
                    {
#>
					protected <#=GetStateMachineEnumName()#> mStateId = <#=GetStateMachineEnumName()#>.<#= state.Name#>;
<#+ 
					}
#>
					public <#= stateMachineName#><#= state.Name #>State(<#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.StateMachineBase machine) : base(machine)
					{
						StateId = (int)mStateId;
					}
				}
<#+ 
                }
#>
<#+ 
						string entityName = null;
						string shortEntityName = null;
						var baseInterfaces = VisualStudioHelper.CodeModel.GetAllBaseInterfaces(Interface);
						foreach(var i in baseInterfaces)
                        {
							if(i.Name == "IReadService" || i.Name == "ICRUDService")
                            {
								string firstArgument = i.FullName.Split('<', '>')[1];
								entityName = firstArgument.Split(',')[0];
								shortEntityName = entityName.Split('.').Last();
                            }
                        }
						
#>
<#+				
				foreach(var triggerName in GetGuardNames(this.CurrentStateGraph))
				{
#>
				public partial class <#= stateMachineName#><#= triggerName #>Trigger : <#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.TriggerBase 
				{
<#+
					if(!string.IsNullOrWhiteSpace(GetStateMachineEnumName()))
                    {
#>
					protected <#= shortEntityName #>TriggerEnum mTriggerId = <#= shortEntityName #>TriggerEnum.<#= shortEntityName #><#= triggerName#>Request;
<#+ 
					}
#>
					static <#= stateMachineName #><#= triggerName #>Trigger()
                    {
                        AutoMapper.Mapper.CreateMap<<#= shortEntityName #><#= triggerName #>Request, <#= entityName #>>().ForAllMembers(opt => opt.Condition(srs => !srs.IsSourceValueNull));
                    }
					public <#= stateMachineName #><#= triggerName #>Trigger()
					{
						TriggerId = (int)mTriggerId;
					}
					public <#= shortEntityName #><#= triggerName #>Request Request {get; set;}
					public override void UpdateEntity(object entity)
					{
						AutoMapper.Mapper.Map(Request, entity);
					}
				}

<#+ 
                }
#>
<#+				
				foreach(var startFlow in CurrentStateGraph.FlowElements.StartPoint.FlowTo.Flow)
				{
#>
					public partial class <#= stateMachineName #><#= startFlow.Guard #>Trigger : <#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.TriggerBase 
				{
<#+
					if(!string.IsNullOrWhiteSpace(GetStateMachineEnumName()))
                    {
#>
					protected <#= shortEntityName #>TriggerEnum mTriggerId = <#= shortEntityName #>TriggerEnum.<#= shortEntityName #><#= startFlow.Guard#>Request;
<#+ 
					}
#>
					static <#= stateMachineName #><#= startFlow.Guard #>Trigger()
                    {
                        AutoMapper.Mapper.CreateMap<<#= shortEntityName #><#= startFlow.Guard #>Request, <#= entityName #>>().ForAllMembers(opt => opt.Condition(srs => !srs.IsSourceValueNull));
                    }
					public <#= stateMachineName #><#= startFlow.Guard #>Trigger()
					{
						TriggerId = (int)mTriggerId;
					}
					public <#= shortEntityName #><#= startFlow.Guard #>Request Request {get; set;}
					public override void UpdateEntity(object entity)
					{
						AutoMapper.Mapper.Map(Request, entity);
					}
				}
<#+ 
                }
#>
				/// <summary>
				/// This class is the actual state machine designed in the State-Diagarm.
				/// </summary>
				public partial class <#= stateMachineName #> : <#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.StateMachineBase
				{
					/// <summary>
					/// Makes the state machine react to a trigger.
					/// </summary>
					public override void ProcessTrigger(<#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.TriggerBase trigger)
					{
						if (this.CurrentState == null) return;
						if (trigger == null) throw new ArgumentException("Trigger must not be null");

						// determine what action to take based on the current state
						// and the given trigger.
						// iterate all states in the diagram
<#+						
						var startState = this.CurrentStateGraph.FlowElements.StartPoint;
#>
						if (this.CurrentState is <#= stateMachineName#><#= startState.Name #>State)
						{
							if(!GetAllowedTriggerList().Contains((AddressTriggerEnum)trigger.TriggerId))
                                    {
                                        throw new ApplicationException("Invalid trigger!");
                                    }
<#+
							foreach(var transition in startState.FlowTo.Flow)
							{
#>
								if (trigger is <#= stateMachineName #><#= transition.Guard#>Trigger)
								{
									this.TransitionToNewState(new <#= stateMachineName#><#=GetNextStateName(startState, transition.Guard)#>State(this), trigger);
								}
<#+ 
							}
#>
						}

<#+						
						foreach(var state in this.CurrentStateGraph.FlowElements.State)
						{
							var possibleTransitions = GetGuardNamesForState(state);
#>
							else if (this.CurrentState is <#= stateMachineName#><#= state.Name #>State)
							{
								if(!GetAllowedTriggerList().Contains((AddressTriggerEnum)trigger.TriggerId))
                                        {
                                            throw new ApplicationException("Invalid trigger!");
                                        }
<#+
								foreach(var transition in possibleTransitions)
								{
#>
									if (trigger is <#= stateMachineName #><#= transition#>Trigger)
									{
										this.TransitionToNewState(new <#= stateMachineName#><#=GetNextStateName(state, transition)#>State(this), trigger);
										
									}
<#+ 
								}
#>
							}
<#+ 
						}
#>

					}

					 public System.Collections.Generic.IList<<#= shortEntityName #>TriggerEnum> GetAllowedTriggerList()
                        {
                            IList<AddressTriggerEnum> triggerList = new List<AddressTriggerEnum>();
<#+						
						var startStateTrigger = this.CurrentStateGraph.FlowElements.StartPoint;
#>
							if (this.CurrentState is <#= stateMachineName#><#= startStateTrigger.Name #>State)
							{
<#+
							foreach(var transition in startStateTrigger.FlowTo.Flow)
							{
#>
									triggerList.Add(<#= shortEntityName #>TriggerEnum.<#= shortEntityName #><#= transition.Guard#>Request);
<#+ 
							}
#>
							}
<#+						
						foreach(var state in this.CurrentStateGraph.FlowElements.State)
						{
							var possibleTransitions = GetGuardNamesForState(state);
#>
							if (this.CurrentState is <#= stateMachineName#><#= state.Name #>State)
							{
<#+
								foreach(var transition in possibleTransitions)
								{
#>
									triggerList.Add(<#= shortEntityName #>TriggerEnum.<#= shortEntityName #><#= transition#>Request);
<#+ 
								}
#>
							}
<#+ 
						}
#>


                            return triggerList;
                        }

<#+
						if(entityName != null)
                        {
#>						
						public <#=entityName#> Entity { get; set; }
						public <#= stateMachineName #>()
						:base()
						{
							
						}
						public override void UpdateEntityState()
                        {
							//Entity: <#=entityName#>
							Entity.<#=GetStateMachinePropertyNameOnModel()#> = (<#=GetStateMachineEnumName()#>)CurrentState.StateId;
                            base.UpdateEntityState();
                        }

						public void Initialize(<#=entityName#> entity)
						{
							//bind entity that we are operating ON
							
							Entity = entity;
							CurrentEntity = entity;
							CurrentState = GetState(entity.<#=GetStateMachinePropertyNameOnModel()#>);
						}

						public <#= VisualStudioHelper.CurrentProject.Properties.Item("DefaultNamespace").Value.ToString()#>.Core.StateBase GetState(<#=GetStateMachineEnumName()#> stateId)
						{
							switch(stateId)
							{
<#+							//var startPoint = this.CurrentStateGraph.FlowElements.StartPoint;
							if(startPoint != null)
							{
#>
								case <#=GetStateMachineEnumName()#>.<#= startPoint.Name#>:
								{
									return new <#= stateMachineName#><#= startPoint.Name #>State(this);
								}
<#+ 
							}
#>
<#+						
						foreach(var state in this.CurrentStateGraph.FlowElements.State)
						{						
#>
								case <#=GetStateMachineEnumName()#>.<#= state.Name#>:
								{
									return new <#= stateMachineName#><#= state.Name #>State(this);
								}
<#+ 
						}
#>
								default:
								{
									throw new ApplicationException("Invalid stateId:" + stateId);
								}
							}

							throw new ApplicationException("States undefined");
						}

<#+
                        }
#>
				}

				public partial class <#=  @interface.Name.ToString().Substring(1) #>
				{
					[Dependency]
					public <#= stateMachineName#> <#= stateMachineName#>Instance { get; set; }
<#+ 
					var methods = VisualStudioHelper.CodeModel.GetAllMethodsOnInterface(@interface);
					foreach(var method in methods)
					{
						EnvDTE.CodeAttribute defaultMethodBehaviour = null;
						var allAttributes = VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(method.Attributes, vsCMElement.vsCMElementAttribute, false).OfType<EnvDTE.CodeAttribute>();
						foreach(var attr in allAttributes)
						{
							if(attr.FullName == DefaultMethodBehaviourAttribute)
							{
								defaultMethodBehaviour = attr;
								break; 
							}
						}
						StringBuilder typeAndNameParamListString = new StringBuilder();
						var allParameters =  VisualStudioHelper.CodeModel.GetAllCodeElementsOfType(method.Parameters, vsCMElement.vsCMElementParameter, true).OfType<EnvDTE.CodeParameter>();
						var firstParam = allParameters.First();
						var lastParam = allParameters.Last();
						foreach(var prm in allParameters)
						{
							typeAndNameParamListString.Append(string.Format("{0} {1},", prm.Type.AsFullName, prm.Name));
						}
						string typeAndNameParamString = typeAndNameParamListString.ToString().TrimEnd(',');
#>
<#+
						if(defaultMethodBehaviour != null && defaultMethodBehaviour.Value == "BehaviourEnum.StateMachineInsert")
						 {
#>
					public virtual <#= shortEntityName #> <#= method.Name #>(<#= typeAndNameParamString #>)
					{
						var entity = CreateNewInstance();

						<#= stateMachineName#>Instance.Initialize(entity);

						<#= stateMachineName#>Instance.ProcessTrigger(new <#= stateMachineName#><#= method.Name #>Trigger() { Request = <#= firstParam.Name #> });
						Entity.Attach(entity);
                        Context.Entry(entity).State = EntityState.Added;
						Save(entity);
						return entity;
					}
<#+ 
						 }
#>
<#+
						if(defaultMethodBehaviour != null && defaultMethodBehaviour.Value == "BehaviourEnum.StateMachineUpdate")
						 {
#>
					public virtual <#= shortEntityName #> <#= method.Name #>(<#= typeAndNameParamString #>)
					{
						var entity = Get(<#= firstParam.Name #>);
						if(entity != null)
						{
							<#= stateMachineName#>Instance.Initialize(entity);

							<#= stateMachineName#>Instance.ProcessTrigger(new <#= stateMachineName#><#= method.Name #>Trigger() { Request = <#= lastParam.Name #> });
							
							Entity.Attach(entity);
							Context.Entry(entity).State = EntityState.Modified;
						
							Save(entity);
						}
						else
						{
							throw new ApplicationException("Entity not found!");
						}
						return entity;
					}
<#+ 
						 }
#>

<#+ 	
					}

 #>					
				}
<#+
            }
        }
		return this.GenerationEnvironment.ToString();
    }
}
#>
